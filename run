#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
from pathlib import Path

# ##################################################################
# paths relative to this script, not cwd
SCRIPT_DIR = Path(__file__).parent.resolve()
TEST_OUT = SCRIPT_DIR / "output" / "testing"
VENV_DIR = SCRIPT_DIR / ".venv"


# ##################################################################
# activate venv
# re-exec under the venv python if we are not already in one
def activate_venv() -> None:
    if VENV_DIR.exists() and "VIRTUAL_ENV" not in os.environ:
        venv_python = VENV_DIR / "bin" / "python"
        if venv_python.exists():
            os.execv(str(venv_python), [str(venv_python)] + sys.argv)


activate_venv()


# ##################################################################
# shell
# run a subprocess and return exit code
def _shell(cmd: list[str], **kwargs: object) -> int:
    return subprocess.call(cmd, **kwargs)


# ##################################################################
# command test
# run pytest for a specific test target
def command_test(args: argparse.Namespace) -> int:
    TEST_OUT.mkdir(parents=True, exist_ok=True)
    target = str(SCRIPT_DIR / args.target)
    return _shell(["pytest", "-q", target, "--maxfail=1", "--disable-warnings", "--tb=short"])


# ##################################################################
# command lint
# run ruff linter on the project
def command_lint(_: argparse.Namespace) -> int:
    return _shell(["ruff", "check", "--line-length", "120", str(SCRIPT_DIR / "src")])


# ##################################################################
# command check
# run full quality gate via dazpycheck
def command_check(_: argparse.Namespace) -> int:
    return _shell(["dazpycheck"], cwd=str(SCRIPT_DIR))


# ##################################################################
# command extract
# extract content from a url and print results
def command_extract(args: argparse.Namespace) -> int:
    import asyncio
    import json
    import setproctitle
    from daz_web_extract import extract

    setproctitle.setproctitle("daz-web-extract")
    result = asyncio.run(extract(args.url))
    if args.raw:
        print(json.dumps(result.to_dict(), indent=2))
    else:
        if result.success:
            print(f"Title: {result.title}")
            print(f"Method: {result.fetch_method}")
            print(f"Length: {result.content_length} chars")
            print(f"Time: {result.elapsed_ms}ms")
            print()
            print(result.body)
        else:
            print(f"Failed: {result.error}", file=sys.stderr)
    return 0 if result.success else 1


# ##################################################################
# command publish
# build and upload the package to pypi
def command_publish(_: argparse.Namespace) -> int:
    import shutil
    for d in ["dist", "build"]:
        build_dir = SCRIPT_DIR / d
        if build_dir.exists():
            shutil.rmtree(build_dir)
    rc = _shell([sys.executable, "-m", "build"], cwd=str(SCRIPT_DIR))
    if rc != 0:
        print("Build failed", file=sys.stderr)
        return rc
    rc = _shell(["twine", "upload", "dist/*"], cwd=str(SCRIPT_DIR))
    if rc != 0:
        print("Upload failed", file=sys.stderr)
        return rc
    for d in ["dist", "build"]:
        build_dir = SCRIPT_DIR / d
        if build_dir.exists():
            shutil.rmtree(build_dir)
    return 0


# ##################################################################
# command verify
# run lint and full test suite for pre-commit verification
def command_verify(_: argparse.Namespace) -> int:
    TEST_OUT.mkdir(parents=True, exist_ok=True)
    rc = _shell(["ruff", "check", "--line-length", "120", str(SCRIPT_DIR / "src")])
    if rc != 0:
        return rc
    return _shell(["pytest", "-q", str(SCRIPT_DIR / "src"), "--disable-warnings", "--tb=short", "-W", "error"])


# ##################################################################
# main
# parse arguments and dispatch to the right command
def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(prog="daz-web-extract")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_test = sub.add_parser("test", help="Run a single test target")
    p_test.add_argument("target", help="e.g. src/daz_web_extract/result_test.py")
    p_test.set_defaults(func=command_test)

    p_lint = sub.add_parser("lint", help="Run linter")
    p_lint.set_defaults(func=command_lint)

    p_check = sub.add_parser("check", help="Run full suite and gates (dazpycheck)")
    p_check.set_defaults(func=command_check)

    p_extract = sub.add_parser("extract", help="Extract content from a URL")
    p_extract.add_argument("url", help="URL to extract")
    p_extract.add_argument("--raw", action="store_true", help="Output raw JSON")
    p_extract.set_defaults(func=command_extract)

    p_publish = sub.add_parser("publish", help="Build and upload to PyPI")
    p_publish.set_defaults(func=command_publish)

    p_verify = sub.add_parser("verify", help="Run lint + full test suite")
    p_verify.set_defaults(func=command_verify)

    args = parser.parse_args(argv)
    return args.func(args)


# ##################################################################
# entry point
if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
