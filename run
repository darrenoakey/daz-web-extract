#!/usr/bin/env python3
import argparse
import subprocess
import sys
from pathlib import Path

# ##################################################################
# paths relative to this script, not cwd
SCRIPT_DIR = Path(__file__).parent.resolve()
TEST_OUT = SCRIPT_DIR / "output" / "testing"
VENV_DIR = SCRIPT_DIR / ".venv"
VENV_BIN = VENV_DIR / "bin"
VENV_PYTHON = VENV_BIN / "python"


# ##################################################################
# shell helpers
# run a subprocess and return exit code
def _shell(cmd: list[str], **kwargs: object) -> int:
    return subprocess.call(cmd, **kwargs)


def _venv(tool: str) -> str:
    """resolve a tool name to its venv bin path"""
    return str(VENV_BIN / tool)


# ##################################################################
# color helpers for status output
_CYAN = "\033[36m"
_GREEN = "\033[32m"
_RED = "\033[31m"
_BOLD = "\033[1m"
_RESET = "\033[0m"


def _status(msg: str) -> None:
    print(f"{_CYAN}{_BOLD}  → {msg}{_RESET}")


def _success(msg: str) -> None:
    print(f"{_GREEN}{_BOLD}  ✓ {msg}{_RESET}")


def _error(msg: str) -> None:
    print(f"{_RED}{_BOLD}  ✗ {msg}{_RESET}", file=sys.stderr)


# ##################################################################
# command test
# run pytest for a specific test target
def command_test(args: argparse.Namespace) -> int:
    TEST_OUT.mkdir(parents=True, exist_ok=True)
    target = str(SCRIPT_DIR / args.target)
    return _shell([_venv("pytest"), "-q", target, "--maxfail=1", "--disable-warnings", "--tb=short"])


# ##################################################################
# command lint
# run ruff linter on the project
def command_lint(_: argparse.Namespace) -> int:
    return _shell([_venv("ruff"), "check", "--line-length", "120", str(SCRIPT_DIR / "src")])


# ##################################################################
# command check
# run full quality gate via dazpycheck
def command_check(_: argparse.Namespace) -> int:
    return _shell(["dazpycheck"], cwd=str(SCRIPT_DIR))


# ##################################################################
# command extract
# extract content from a url via venv subprocess
def command_extract(args: argparse.Namespace) -> int:
    cmd = [_venv("python"), "-c", ";".join([
        "import asyncio, json, sys, setproctitle",
        "from daz_web_extract import extract",
        "setproctitle.setproctitle('daz-web-extract')",
        f"r=asyncio.run(extract({args.url!r}))",
        f"print(json.dumps(r.to_dict(),indent=2)) if {args.raw!r} else None",
        f"print(f'Title: {{r.title}}\\nMethod: {{r.fetch_method}}\\nLength: {{r.content_length}} chars\\n"
        f"Time: {{r.elapsed_ms}}ms\\n\\n{{r.body}}') if not {args.raw!r} and r.success else None",
        f"print(f'Failed: {{r.error}}',file=sys.stderr) if not {args.raw!r} and not r.success else None",
        "sys.exit(0 if r.success else 1)",
    ])]
    return _shell(cmd)


# ##################################################################
# command publish
# build and upload the package to pypi
def command_publish(_: argparse.Namespace) -> int:
    import glob
    import re
    import shutil

    pyproject = SCRIPT_DIR / "pyproject.toml"
    content = pyproject.read_text()
    match = re.search(r'version\s*=\s*"([^"]+)"', content)
    version = match.group(1) if match else "unknown"
    name_match = re.search(r'name\s*=\s*"([^"]+)"', content)
    name = name_match.group(1) if name_match else "daz-web-extract"

    print(f"\n{_BOLD}Publishing {name} v{version} to PyPI{_RESET}\n")

    _status("Cleaning previous builds...")
    for d in ["dist", "build"]:
        build_dir = SCRIPT_DIR / d
        if build_dir.exists():
            shutil.rmtree(build_dir)

    _status("Building distribution...")
    rc = _shell([_venv("python"), "-m", "build"], cwd=str(SCRIPT_DIR))
    if rc != 0:
        _error("Build failed")
        return rc
    _success("Distribution built")

    dist_files = glob.glob(str(SCRIPT_DIR / "dist" / "*"))
    if not dist_files:
        _error("No dist files found after build")
        return 1

    _status("Uploading to PyPI...")
    rc = _shell([_venv("twine"), "upload"] + dist_files)
    if rc != 0:
        _error("Upload failed")
        return rc
    _success("Uploaded to PyPI")

    _status("Cleaning up...")
    for d in ["dist", "build"]:
        build_dir = SCRIPT_DIR / d
        if build_dir.exists():
            shutil.rmtree(build_dir)

    print(f"\n{_GREEN}{_BOLD}  Published {name} v{version} to PyPI!{_RESET}")
    print(f"{_CYAN}  pip install {name}{_RESET}\n")
    return 0


# ##################################################################
# command verify
# run lint and full test suite for pre-commit verification
def command_verify(_: argparse.Namespace) -> int:
    TEST_OUT.mkdir(parents=True, exist_ok=True)
    rc = _shell([_venv("ruff"), "check", "--line-length", "120", str(SCRIPT_DIR / "src")])
    if rc != 0:
        return rc
    return _shell([_venv("pytest"), "-q", str(SCRIPT_DIR / "src"), "--disable-warnings", "--tb=short", "-W", "error"])


# ##################################################################
# main
# parse arguments and dispatch to the right command
def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(prog="daz-web-extract")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_test = sub.add_parser("test", help="Run a single test target")
    p_test.add_argument("target", help="e.g. src/daz_web_extract/result_test.py")
    p_test.set_defaults(func=command_test)

    p_lint = sub.add_parser("lint", help="Run linter")
    p_lint.set_defaults(func=command_lint)

    p_check = sub.add_parser("check", help="Run full suite and gates (dazpycheck)")
    p_check.set_defaults(func=command_check)

    p_extract = sub.add_parser("extract", help="Extract content from a URL")
    p_extract.add_argument("url", help="URL to extract")
    p_extract.add_argument("--raw", action="store_true", help="Output raw JSON")
    p_extract.set_defaults(func=command_extract)

    p_publish = sub.add_parser("publish", help="Build and upload to PyPI")
    p_publish.set_defaults(func=command_publish)

    p_verify = sub.add_parser("verify", help="Run lint + full test suite")
    p_verify.set_defaults(func=command_verify)

    args = parser.parse_args(argv)
    return args.func(args)


# ##################################################################
# entry point
if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
